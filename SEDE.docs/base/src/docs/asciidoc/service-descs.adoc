= Service Description Language
SDL
:toc: left
//:pr-root: link:../../../../../
:pr-root: https://github.com/fmohr/SEDE/tree/dev/docs/
:pr-servicedesc: {pr-root}SEDE.core/servicedesc/
:pr-servicedesc-dsl: {pr-root}SEDE.core/servicedesc-dsl/
:pr-docs: {pr-root}SEDE.docs/base/src/docs/asciidoc/
:pr-hasco: https://github.com/fmohr/AILibs/tree/master/softwareconfiguration/hasco
:todo: pass:q[[small blue]#TODO#]
:old-classconf-example: https://github.com/fmohr/SEDE.services/blob/master/weka.ml/src/main/resources/config/weka-ml-classifiers-classconf.json
:j-src: src/main/java/de/upb/sede/
:download-link-sdlc: {pr-docs}sdlc.jar
//{pr-servicedesc}{j-src}/ServiceDescSchemaGenerator.java[SchemaGen]

This document contains a user guide for creating and managing service descriptions. For the development guide, see: {todo}.

== What is a service description?

A service description is an object graph that contains meta-information about a *software library*.
It *describes* how to deploy, configure, run and compose its functionality.
Given this meta-data, the library seamlessly *integrates* into the SEDE-Framework and its units of functionality can be offered as a *set of services*.

== Why a domain specific language?

Previously, services
footnote:[In context of service descriptions, the role of software libraries do not differ from services and the terms are used *synonymously*.]
were specified by painstakingly creating  {old-classconf-example}[large class-config files].
The advantage of having a simple json-format was neutralized by numerous down sides:

* For one, these files were barely human readable. After a few iteration of feature-sets being added to the specification of services, the json-format could not contain the load of information in a *concise manner*.

* Additionally, seemingly small *changes* to a subset of the services, like a method name change, had to be done with small python scripts, search and replaces or even manual labor; bringing careless mistakes and human errors with it.

* Finally, all aspects of the specification of each service had to be defined in a single place footnote:[Single place means a distinct json-object in single document]. Any *additional* information about an already specified service did not *accumulate with the rest* but instead overwrote the previous specification.

To overcome these problems, we decided to introduce a thin layer of logic on top of the {pr-servicedesc}[*object models* of service descriptions].
This was done by implementing a
{pr-servicedesc-dsl}[custom Groovy DSL]
footnote:[For more details on what a *Groovy DSL* is have a look at the link:http://docs.groovy-lang.org/docs/latest/html/documentation/core-domain-specific-languages.html[documentation] on this subject.]
that handles incremental and declarative user scripts that creats and manipules an objects graph.

== Usage

This section informs on how to install and make use of the SDL compiler. The primary client, however, are other SEDE components.

=== The Big Picture

The service description language is built upon the concept of inceremental, declarative changes to one or more {pr-servicedesc}{j-src}ServiceCollectionsDescription.java[service collection] objects.
The SDL compiler expects two kind of user *inputs*.

* An *ordered* list of `.servicedesc.json` data, with base specification of services. May be empty.
* An *ordered* list of `.servicedesc.groovy` scripts, with additional specification and alterations. May be empty.

Based on the user needs, the generated *output* of the compiler may be:

* A `.servicedesc.json` file as a resulting from the *merge* of specification and alteration of service collections.
* {todo} Component models with dependencies and parameter options of services, used by {pr-hasco}[HASCO].
* {todo} Service Specification in used by SFB-OTF _testbed_ team.
* {todo} More to come.

=== SDL Compiler

The SDL compiler is an executable jar program that can be used to manually transcribe SDL files into a desired target format.
Download it from this link: {download-link-sdlc}[sdl.jar]

General usage:
{todo} update the help output

[source]
----
include::sdlc-usage.txt[]
----
<1> If the components flag is enabled, the output file is a HASCO component model.
<2> Provide one or more input files. Note that the order determines which change comes through. For more information, see examples below.
<3> Provide a single output file. This file will be overwritten with the output of the compilation.

=== SDL Gradle Project

It will also be possible to include sdl files in a gradle project and benefit from autocomplete features of IDEs.
{todo} SDL gradle plugin.


== Object Model Class Diagram

This uml class diagram shows an excerpt of the object model graph responsible for capturing service runtime descriptions.

[plantuml,"classdiag",svg]
....
include::../plantuml/service-descs-overview.plantuml[]
....

== Examples

In the following we build a service description for a fictional math library.

=== Service Collection

The {pr-servicedesc}{j-src}IServiceCollectionDesc.java[Service Collection] contains all services that will eventually be offered by the library.
One can, alternatively, split the services up into multiple service collections, for example to organize services into different thematic categories.

[source, groovy]
.MathLib-1.servicedesc.groovy
----
include::MathLib-1.servicedesc.groovy[]
----
<1> Create a collection with the qualifier `MathLib`
<2> Add a multi-line info block for the collection.
<3> Define a simple name for the collection.

Use the compiler to create a json model of this description:

[source, bash]
----
java -jar sdlc.jar -i MathLib-1.servicedesc.groovy -o MathLib.servicedesc.json
----

This is the generated output:

[source, json]
.MathLib.servicedesc.json
----
include::MathLib-1.servicedesc.json[]
----

=== Service

A {pr-servicedesc}{j-src}exec/IServiceDesc.java[Service] description offers *parametrization*, defines *state* and groups a set of common *functionality.
The next file adds a `Primes` service to out `MathLib` Service Collection that is able to generate prime numbers.

[source, groovy]
.MathLib-2.servicedesc.json
----
include::MathLib-2.servicedesc.groovy[]
----
<1> Similiar to `typedef`, predefine the `Number` type into a  variable and reuse the number variable inside this document.
<2> We can overwrite the previous specification; in this case the simple name of the collection has been renamed.
<3> Create a service with the qualifier: `ai.libs.Primers`.
<4> Create a method inside of the service called `generateRandom`.
<5> Overload the previous method definition with a different signature. Both method definitions are preserved and are seen separately.
<6> This method definiton contains an aditional https://groovy-lang.org/closures.html[Closure] that includes additional tweaks of method properties.
<7> Set the name of the first input parameter. This does not have any functional side-effect for now.
<8> Enable the isPure flag, which indicates that the method is considered https://en.wikipedia.org/wiki/Pure_function[pure]. This additional information helps optimize its runtime , for example  by internally resusing cached results.

Compile the added specification:

[source, bash]
----
java -jar sdlc.jar \
    -i MathLib-1.servicedesc.groovy MathLib-2.servicedesc.groovy <1>
    -o MathLib.servicedesc.json <2>
----
<1> Multiple input files
<2> Single output, which contains the merged result

NOTE: The sdl file of the previous example is reused. This way the second service description merely updates the `MathLib` collection and retains the info block. Note that the order of the input files determine which change comes through.

The resulting json file now becomes:

[source, json]
.MathLib.servicedesc.json (First 20 lines)
----
include::MathLib-2.servicedesc.json[lines=1..20]
----

=== Data Type

By defining custom {pr-servicedesc}{j-src}types/IDataTypeRef.java[Data Types], the library can work with arbitrarily complex data:

[source, groovy]
.MathLib-3.servicedesc.json
----
include::MathLib-3.servicedesc.groovy[]
----
<1> Create a new type `ai.libs.Function`. Add details about the java implementation, by specifying which class this data type is mapped to.
<2> Define  a semantic type of the data type. In simple terms, this guarantees that the serialized form of this data type is compatible with all data types whose semantic type matched this.
<3> Create a new Service that makes use of these data types.
<4> Specify that `DotService` is characterized by an instance of Function, i.e.: its complete state is contained in a function. In the previous example no state was defined which implies that the service is stateless.
<5> Define a new method that returns instances of Dot.

=== Service Parametrization
{pr-servicedesc}{j-src}param/IServiceParameterizationDesc.java[Service Parameters] can be included into service descriptions in order to inform clients on service tuning options.
The design of Service Parametrization was done with integration into HASCO in mind:

[source, groovy]
.MathLib-4.servicedesc.json
----
include::MathLib-4.servicedesc.groovy[]
----
<1> Add boolean parameters
<2> Add a numeric parameter
<3> Add a category parameter
<4> Add a dependency between two parameters

== Advanced Examples

{todo}

